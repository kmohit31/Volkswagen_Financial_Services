"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStepArgument = createStepArgument;
exports.getTestParent = getTestParent;
exports.getTestStepTitle = getTestStepTitle;
exports.getTestFullTitle = getTestFullTitle;
exports.getUniqueIdentifier = getUniqueIdentifier;
exports.formatMessage = formatMessage;
exports.getStepType = getStepType;
exports.buildStepPayload = buildStepPayload;
exports.compareScenarioLineWithSourceLine = compareScenarioLineWithSourceLine;
exports.getStepFromFeature = getStepFromFeature;
exports.setUserHookNames = setUserHookNames;
exports.wrapWithHooks = wrapWithHooks;
exports.notifyStepHookError = notifyStepHookError;
exports.getDataFromResult = void 0;

var path = _interopRequireWildcard(require("path"));

var _config = require("@wdio/config");

var _utils = require("@wdio/utils");

var _constants = require("./constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createStepArgument({
  argument
}) {
  if (!argument) {
    return undefined;
  }

  if (argument.type === 'DataTable') {
    return {
      rows: argument.rows.map(row => ({
        cells: row.cells.map(cell => cell.value),
        locations: row.cells.map(cell => cell.location)
      }))
    };
  }

  if (argument.type === 'DocString') {
    return argument.content;
  }

  return undefined;
}

function getTestParent(feature, scenario) {
  return `${feature.name || 'Undefined Feature'}: ${scenario.name || 'Undefined Scenario'}`;
}

function getTestStepTitle(keyword = '', text = '', type) {
  const title = !text && type !== 'hook' ? 'Undefined Step' : text;
  return `${keyword.trim()} ${title.trim()}`.trim();
}

function getTestFullTitle(parent, stepTitle) {
  return `${parent}: ${stepTitle}`;
}

function getUniqueIdentifier(target, sourceLocation) {
  if (target.type === 'Hook') {
    return `${path.basename(target.location.uri)}${target.location.line}`;
  }

  if (target.type === 'ScenarioOutline') {
    let name = target.name || target.text;
    const line = sourceLocation.line || '';

    if (Array.isArray(target.examples)) {
      target.examples[0].tableHeader.cells.forEach((header, idx) => {
        if (name.indexOf('<' + header.value + '>') === -1) {
          return;
        }

        target.examples[0].tableBody.forEach(tableEntry => {
          if (tableEntry.location.line === sourceLocation.line) {
            name = name.replace('<' + header.value + '>', tableEntry.cells[idx].value);
          }
        });
      });
    }

    return `${name}${line}`;
  }

  const name = target.name || target.text;
  const location = target.location || target.locations[0];
  const line = location && location.line || '';
  return `${name}${line}`;
}

function formatMessage({
  payload = {}
}) {
  let content = _objectSpread({}, payload);

  if (payload.error && (payload.error.message || payload.error.stack)) {
    const {
      name,
      message,
      stack
    } = payload.error;
    content.error = {
      name,
      message,
      stack
    };
  }

  if (payload.title && payload.parent) {
    content.fullTitle = getTestFullTitle(payload.parent, payload.title);
  }

  return content;
}

function getStepType(type) {
  return type === 'Step' ? 'test' : 'hook';
}

function buildStepPayload(uri, feature, scenario, step, params = {}) {
  return _objectSpread({
    uid: getUniqueIdentifier(step),
    title: getTestStepTitle(step.keyword, step.text, params.type),
    parent: getTestParent(feature, scenario),
    argument: createStepArgument(step),
    file: uri,
    tags: scenario.tags,
    keyword: step.keyword,
    featureName: feature.name,
    scenarioName: scenario.name
  }, params);
}

function compareScenarioLineWithSourceLine(scenario, sourceLocation) {
  if (scenario.type.indexOf('ScenarioOutline') > -1) {
    return scenario.examples.some(example => example.tableBody.some(tableEntry => tableEntry.location.line === sourceLocation.line));
  }

  return scenario.location.line === sourceLocation.line;
}

function getStepFromFeature(feature, pickle, stepIndex, sourceLocation) {
  let combinedSteps = [];
  feature.children.forEach(child => {
    if (child.type.indexOf('Scenario') > -1 && !compareScenarioLineWithSourceLine(child, sourceLocation)) {
      return;
    }

    combinedSteps = combinedSteps.concat(child.steps);
  });
  const targetStep = combinedSteps[stepIndex];

  if (targetStep.type === 'Step') {
    const stepLine = targetStep.location.line;
    const pickleStep = pickle.steps.find(s => s.locations.some(loc => loc.line === stepLine));

    if (pickleStep) {
      return _objectSpread({}, targetStep, {
        text: pickleStep.text
      });
    }
  }

  return targetStep;
}

const getDataFromResult = ([{
  uri
}, feature, ...scenarios]) => ({
  uri,
  feature,
  scenarios
});

exports.getDataFromResult = getDataFromResult;

function setUserHookNames(options) {
  _constants.CUCUMBER_HOOK_DEFINITION_TYPES.forEach(hookName => {
    options[hookName].forEach(testRunHookDefinition => {
      const hookFn = testRunHookDefinition.code;

      if (!hookFn.name.startsWith('wdioHook')) {
        const userHookAsyncFn = async function (...args) {
          return hookFn.apply(this, args);
        };

        const userHookFn = function (...args) {
          return hookFn.apply(this, args);
        };

        testRunHookDefinition.code = (0, _utils.isFunctionAsync)(hookFn) ? userHookAsyncFn : userHookFn;
      }
    });
  });
}

function wrapWithHooks(type, code, before, after, cid) {
  const userFn = async function (...args) {
    const {
      uri,
      feature
    } = getDataFromResult(global.result);
    notifyStepHookError(`Before${type}`, (await (0, _config.executeHooksWithArgs)(before, [uri, feature])), cid);
    let result;
    let error;

    try {
      result = await (0, _config.runFnInFiberContext)(code.bind(this, ...args))();
    } catch (err) {
      error = err;
    }

    notifyStepHookError(`After${type}`, (await (0, _config.executeHooksWithArgs)(after, [uri, feature, {
      error,
      result
    }])), cid);

    if (error) {
      throw error;
    }

    return result;
  };

  return userFn;
}

function notifyStepHookError(hookName, hookResults = [], cid) {
  const result = hookResults.find(result => result instanceof Error);

  if (typeof result === 'undefined') {
    return;
  }

  const content = formatMessage({
    payload: {
      cid: cid,
      error: result,
      fullTitle: `${hookName} Hook`,
      type: 'hook',
      state: 'fail'
    }
  });
  process.send({
    origin: 'reporter',
    name: 'printFailureMessage',
    content
  });
}